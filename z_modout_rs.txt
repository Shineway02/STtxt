z_modout_rs01:--z_modout_rs01

SET QUOTED_IDENTIFIER OFF

declare @t_bnoa nvarchar(30)
declare @t_enoa nvarchar(30)

set @t_bnoa= case when '#non' = [1] then '' else [1] end
set @t_enoa= case when '#non' = [2] then char(255) else [2] end
-----------------------------------------------------------------------------
declare @tmp table(
	gno nvarchar(1),
	rec int,
	modnoa nvarchar(50),
	mech nvarchar(50),
	datea nvarchar(50),
	code nvarchar(50),
	detail nvarchar(50),
	frame nvarchar(10),
	mount float
)

insert into @tmp
select '0',ROW_NUMBER()over(partition by a.modnoa order by b.code),a.modnoa,a.mech,a.datea,b.code,b.detail,MAX(b.frame),SUM(b.mount) from modout a
left join modouts b on a.noa = b.noa
where(a.modnoa between @t_bnoa and @t_enoa)
group by a.modnoa,a.mech,a.datea,b.code,b.detail

declare @modnoa nvarchar(50)
declare @cnt  int
declare @max  int
declare @i    int

declare cursor_table cursor for 
select modnoa from @tmp group by modnoa
open cursor_table 
fetch next from cursor_table 
into @modnoa
while(@@FETCH_STATUS <> -1) 
begin
	set @cnt = (select COUNT(*) from @tmp where modnoa = @modnoa)
	set @max = (select MAX(rec) from @tmp where modnoa = @modnoa)
	set @i = 0
	while(@i < 25-@cnt%25)
	begin
		insert into @tmp(gno,rec,modnoa)
		select '0',@max+1,@modnoa
			
		set @max = @max + 1
		set @i   = @i   + 1
	end
	
	fetch next from cursor_table 
	into @modnoa
end 
close cursor_table 
deallocate cursor_table

select * from @tmp order by modnoa,rec;
--**************************************************************************
z_modout_rs02:--z_modout_rs02

SET QUOTED_IDENTIFIER OFF

declare @t_bnoa nvarchar(30)
declare @t_enoa nvarchar(30)

set @t_bnoa= case when '#non' = [1] then '' else [1] end
set @t_enoa= case when '#non' = [2] then char(255) else [2] end
-----------------------------------------------------------------------------
declare @tmp table(
	gno nvarchar(1),
	rec int,
	noa nvarchar(50),
	tgg nvarchar(50),
	datea nvarchar(50),
	usetype nvarchar(50),
	frame nvarchar(50),
	code nvarchar(10),
	detail nvarchar(50),
	class nvarchar(10),
	weight float,
	bebottom float,
	enbottom float,
	way nvarchar(30),
	datea1 nvarchar(50),
	datea2 nvarchar(50),
	times float,
	mount float,
	mech  nvarchar(50),
	worker  nvarchar(10)
)
insert into @tmp(gno,rec,noa,tgg,datea,usetype,frame,code)
select 
	'0',ROW_NUMBER()over(partition by a.noa order by c.nob),a.noa,a.tgg,a.datea,
	case when a.usetype='1' then '設備課' else '製造課' end,a.frame,b.number
from model a
left join models b on a.noa = b.noa
left join modfixs  c on b.productno = c.nob
left join modfixcs  d on b.productno = d.nob
left join modfixcs  e on b.productno = e.nob
where (a.noa between @t_bnoa and @t_enoa)and
	  exists (select * from modfixs  where nob = b.productno)and
	  exists (select * from modfixcs where nob = b.productno)and
	  exists (select * from modouts  where nob = b.productno)
	  
declare @rec int
declare @noa nvarchar(50)
declare @xnoa nvarchar(50) = 'xxxxxx'
declare @code nvarchar(50)

declare cursor_table cursor for 
select noa,code from @tmp group by noa,code
open cursor_table 
fetch next from cursor_table 
into @noa,@code
while(@@FETCH_STATUS <> -1) 
begin
	if(@noa != @xnoa)
	begin
		set @rec = 2
		set @xnoa = @noa
	end	
	
	insert into @tmp(gno,rec,noa,code,detail,class,weight,way,datea1,mount,mech)
	select '1',@rec,@noa,@code,b.detail1,'入庫維修',SUM(b.weight1),MAX(b.way1),a.datea,SUM(b.mount1),a.mech 
	from modfix a
	left join modfixs b on a.noa = b.noa
	where(a.modnoa = @noa and b.code1 = @code)
	group by a.datea,a.mech,b.detail1
	set @rec = @rec + 1
	
	insert into @tmp(gno,rec,noa,code,detail,class,bebottom,enbottom,way,datea1,datea2,mount,mech,worker)
	select '2',@rec,@noa,@code,b.detail,'維修',MIN(b.bebottom),MIN(b.enbottom),MAX(b.way),MIN(b.datea1),MAX(b.datea2),SUM(b.mount),a.mech,MAX(b.worker)
	from modfixc a
	left join modfixcs b on a.noa = b.noa
	where(a.modnoa = @noa and b.code = @code)
	group by a.mech,b.detail
	set @rec = @rec + 1
	
	insert into @tmp(gno,rec,noa,code,detail,class,enbottom,datea1,mount,mech)
	select '3',@rec,@noa,@code,b.detail,'領用出庫',MIN(c.enbottom),a.datea,SUM(b.mount),a.mech
	from modout a
	left join modouts b on a.noa = b.noa
	left join modfixcs c on b.nob = c.nob
	where(a.modnoa = @noa and b.code = @code)
	group by a.datea,a.mech,b.detail
	set @rec = @rec + 1

	fetch next from cursor_table 
	into @noa,@code
end 
close cursor_table 
deallocate cursor_table 

delete @tmp where gno = '0' and rec != 1

update @tmp set times =
	ROUND((DATEDIFF(minute,CAST(dbo.ChineseEraName2AD(dbo.split(datea1,'-','0'))as nvarchar(20))+' '+dbo.split(datea1,'-','1') ,CAST(dbo.ChineseEraName2AD(dbo.split(datea2,'-','0'))as nvarchar(20))+' '+dbo.split(datea2,'-','1')))/60.0,1)
where gno = '2'

update @tmp set code = noa + code
update @tmp set datea1 = datea1+'(入庫日期)' where gno = '1'
update @tmp set datea1 = REPLACE(datea1,'-',' ')+'(完成起時間)' ,datea2 = REPLACE(datea2,'-',' ')+'(完成訖時間)'where gno = '2'
update @tmp set datea1 = datea1+'(出庫日期)' where gno = '3'

declare @cnt  int
declare @max  int
declare @i    int

declare cursor_table cursor for 
select noa from @tmp group by noa
open cursor_table 
fetch next from cursor_table 
into @noa
while(@@FETCH_STATUS <> -1) 
begin
	set @cnt = (select COUNT(*) from @tmp where noa = @noa)
	set @max = (select MAX(rec) from @tmp where noa = @noa)
	set @i = 0
	while(@i < 25-@cnt%25)
	begin
		insert into @tmp(gno,rec,noa)
		select '4',@max+1,@noa
			
		set @max = @max + 1
		set @i   = @i   + 1
	end
	
	fetch next from cursor_table 
	into @noa
end 
close cursor_table 
deallocate cursor_table

select * from @tmp order by noa,rec;
--**************************************************************************
z_modout_rs03:--z_modout_rs03
SET QUOTED_IDENTIFIER OFF
declare @t_nob nvarchar(30)
set @t_nob= case when '#non' = [2] then '' else [2] end
----------------------------------------------------------------------------
--declare @b_nob nvarchar(30)=(select b.productno from model a left join models b on a.noa=b.noa where  b.productno like @t_nob+'%')
--表頭資料
declare @b_tgg nvarchar(30)=(select max(a.tgg) from model a left join models b on a.noa=b.noa where b.productno like @t_nob+'%')
declare @b_datea nvarchar(30)=(select max(a.datea) from model a left join models b on a.noa=b.noa where b.productno like @t_nob+'%')
declare @b_mount nvarchar(30)=(select max(a.mount) from model a left join models b on a.noa=b.noa where b.productno like @t_nob+'%')
declare @b_usetype nvarchar(30)=(select max(a.usetype) from model a left join models b on a.noa=b.noa where b.productno like @t_nob+'%')
declare @b_frame nvarchar(30)=(select max(a.frame) from model a left join models b on a.noa=b.noa where b.productno like @t_nob+'%')

declare @result table(
	gno nvarchar(1),
	nob nvarchar(30),
	detail nvarchar(100),
	type nvarchar(30),
	weight float,
	bebottom float,
	enbottom float,
	way nvarchar(50),
	datea1 nvarchar(20),
	datea2 nvarchar(20),
	worktime float,
	mount float,
	mech nvarchar(30),
	worker nvarchar(30)

)

declare @nob nvarchar(30)


DECLARE cursor_table CURSOR FOR 
select nob from modfixs b left join modfix a on a.noa=b.noa where b.nob like @t_nob+'%'
OPEN cursor_table
FETCH NEXT FROM cursor_table
INTO @nob
WHILE @@FETCH_STATUS = 0
BEGIN
--插入入庫維修資料
   insert @result (nob,detail,type,weight,way,datea1,mount,mech)
   select max(b.nob),max(b.detail1),'入庫維修',max(b.weight1),b.way1,max(a.datea),sum(b.mount1),max(a.mech)
   from modfixs b left join modfix a on a.noa=b.noa
   where @nob=b.nob
   group by b.nob
--插入維修資料   
   insert @result(nob,detail,type,bebottom,enbottom,
   way,datea1,datea2,mount,mech,worker,worktime)
   select max(b.nob),max(b.detail),'維修',sum(b.bebottom),sum(b.enbottom),
   case when max(b.way) =1 then'傳統車床(砂紙研磨)'
			 when max(b.way) =2 then'傳統車床(砂輪機研磨)'
			 when max(b.way) =3 then'CNC 車修'
			 when max(b.way) =4 then'不須車修或研磨'
			 else '' end way,
  			 replace(max(b.datea1),'-',' '),replace(max(b.datea2),'-',' '),
			 sum(b.mount),max(a.mech),max(b.worker),
		  	 convert(float,DATEDIFF(MINUTE,
		  	 convert(datetime,replace(convert(nvarchar,(convert(float,left(max(b.datea1),3))+1911))+SUBSTRING(max(b.datea1),4,20),'-',' ')),
		  	 convert(datetime,replace(convert(nvarchar,(convert(float,left(max(b.datea2),3))+1911))+SUBSTRING(max(b.datea2),4,20),'-',' '))
		  	 ))/60
   from modfixcs  b left join modfixc a on a.noa=b.noa
   where @nob=b.nob
   group by b.nob
--插入領用出庫資料
   insert @result(nob,detail,type,enbottom,datea1,mount,mech)
   select max(b.nob),max(b.detail),'領用出庫',(select sum(enbottom) from modfixcs c where b.nob=c.nob)
		,max(a.datea),sum(a.mount),max(a.mech)
	from modouts b left join modout a on a.noa=b.noa
	where @nob=b.nob
  	group by b.nob
  fetch next from cursor_table 
  into @nob
end 

CLOSE cursor_table
DEALLOCATE cursor_table

select '0' gno ,nob,detail,type,weight,bebottom,enbottom
		,way,datea1,datea2,worktime,mount,mech,worker
		,@t_nob bnoa,@b_tgg btgg,@b_datea bdatea
		,@b_mount bmount,@b_usetype buse,@b_frame bframe
from @result;

z_modout_rs04:--z_modout_rs04

declare @t_bdate nvarchar(20)
declare @t_edate nvarchar(20)
declare @t_worker nvarchar(100)
set @t_bdate = case when '#non' = [3] then ''  else [3] end
set @t_edate = case when '#non' = [4] then char(255) else [4] end
set @t_worker = case when '#non' = [5] then '' else [5] end
declare @result table(
	worker nvarchar(100),
	noa nvarchar(30),
	detail nvarchar(50),
	type nvarchar(20),
	mech nvarchar(30),
	weight float,
	betn float,
	ebtn float,
	way float,
	datea1 nvarchar(20),
	datea2 nvarchar(20),
	datea3 nvarchar(20),
	mount float,
	datea4 nvarchar(20)
)

insert @result
select MAX(b.worker) worker,a.modnoa+b.code noa,max(b.detail) detail,'維修',max(a.mech) mech,sum(d.weight1) weight,max(b.bebottom) betn
	  ,max(b.enbottom)ebtn,max(b.way) way,max(c.datea) datea1,max(b.datea1) datea2,max(b.datea2) datea3,sum(b.mount) mount,
	   max(a.datea) datea4
from modfixcs b left join modfixc a on a.noa=b.noa
				left join modfix c on a.innoa=c.noa
				left join modfixs d on b.nob=d.nob
where a.datea between @t_bdate and @t_edate	 and
	  (b.worker =@t_worker or isnull(@t_worker,'')='')
group by a.modnoa+b.code

select '0' gno ,worker man,noa,detail,type,mech,weight,betn,ebtn,
		case when way =1 then'傳統車床(砂紙研磨)'
			 when way =2 then'傳統車床(砂輪機研磨)'
			 when way =3 then'CNC 車修'
			 when way =4 then'不須車修或研磨'
			 else '' end way
		,datea1 dtt1,
		datea2+case when isnull(datea2,'')='' then '' else '~' end
		+datea3 dtt2, mount,datea4 dtt4 
from @result;

z_modout_rs05:--z_modout_rs05

declare @t_noa nvarchar(20)
declare @t_frame nvarchar(100)
set @t_noa= case when '#non' = [1] then '' else [1] end
set @t_frame = case when '#non' = [6] then '' else [6] end
-------------------------------------------------------------------------------------------------
declare @result table(
	noa nvarchar(50),
	frame float,
	nob nvarchar(30),
	detail nvarchar(50),
	type nvarchar(50),
	mech nvarchar(50),
	weight float,
	betm float,
	ebtm float,
	way float,
	datea nvarchar(20),
	mount float,
	worker nvarchar(30)
)
insert @result
select max(a.modnoa),max(c.frame),a.modnoa+c.code,max(c.detail),'入庫維修',max(a.mech),sum(b.weight1),sum(c.bebottom),sum(c.enbottom) 
	,max(c.way),max(a.datea),sum(b.mount1),max(c.worker) 
from modfixs b left join modfix a on a.noa=b.noa 
	left join modfixcs c on b.nob=c.nob 
where (isnull(c.datea1,'')='' or isnull(c.datea2,'')='') and a.modnoa = @t_noa 
	and(c.frame=@t_frame or ISNULL(@t_frame,'')='') 
group by a.modnoa+c.code


select '0'gno,@t_noa noa,frame,detail,type,mech,dbo.getComma(weight,0)
	   ,betm,ebtm,weight,noa nob
	   ,case when way =1 then'傳統車床(砂紙研磨)'
			 when way =2 then'傳統車床(砂輪機研磨)'
			 when way =3 then'CNC 車修'
			 when way =4 then'不須車修或研磨'
			 else '' end way
		,datea dtt1,mount,worker man
from @result;

------------------------------------------------------------------------------------------------------
z_modout_rs06:--z_modout_rs06

declare @t_bdate nvarchar(100) 
declare @t_edate nvarchar(100) 
set @t_bdate = case when '#non' = [3] then ''  else [3] end
set @t_edate = case when '#non' = [4] then char(255) else [4] end
------------------------------------------------------------------------------------------------------
IF OBJECT_ID('tempdb..#tmp')is not null
	BEGIN
		drop table #tmp
	END
create table #tmp (
	a1 nvarchar(100),
	a2 nvarchar(100),
	a3 nvarchar(100),
	a4 nvarchar(100),
	a5 nvarchar(100),
	a6 nvarchar(100),
	a7 nvarchar(100),
	a8 nvarchar(100),
	a9 nvarchar(100),
	a10 nvarchar(100),
	seq float
	
)
--左邊行數
declare @rowcount float=19
declare @i float =0

while @i < @rowcount
	begin
		insert #tmp(seq)
		select @i
		set @i=@i+1
	end
declare @j float =1

declare @mech nvarchar(100),@num nvarchar(100)
--where datea between @t_bdate and @t_edate 
DECLARE cursor_table CURSOR FOR 
select b.namea,a.device from modeqs b left join modeq a on a.noa=b.noa	order by  b.namea
OPEN cursor_table
FETCH NEXT FROM cursor_table
INTO @mech,@num
WHILE @@FETCH_STATUS = 0
BEGIN
------本日-------------------------------------------------------------------
	--成型段 
	declare @sum1 float=(
	select sum(c.mount)
	from  modout b  left join modouts c on b.noa=c.noa
	where (left(c.code,1)='f' or left(c.code,2)='sg' or  left(c.code,2)='sq')
			and c.datea between @t_bdate and @t_edate  and b.mech = @mech)
	exec('update #tmp set a'+@j+' ='''+@sum1+''' where seq=1')
	--定徑段 
	declare @sum2 float=(
	select sum(c.mount)
	from  modout b  left join modouts c on b.noa=c.noa
	where (left(c.code,1)!='f' and left(c.code,2)!='sg' and  left(c.code,2)!='sq')
			and c.datea between @t_bdate and @t_edate
			and b.mech =@mech
	 		) 
	exec('update #tmp set a'+@j+' ='''+@sum2+''' where seq=2')
	declare @total float = @sum1+@sum2
	--合計
	exec('update #tmp set a'+@j+' ='''+@total+''' where seq=3')
	--成型段產量
	declare @smount1 float=(
		select sum(c.weight1)
		from  modfixs c   left join modfix d on c.noa =d.noa
		where (left(c.code1,1)='f' or left(c.code1,2)='sg' or  left(c.code1,2)='sq' )
				and d.datea between @t_bdate and @t_edate
				and d.mech =@mech		
		)
	exec('update #tmp set a'+@j+' ='''+@smount1+''' where seq=4')
	
	--定俓段產量
	declare @smount2 float=(
		select sum(c.weight1)
		from  modfixs c   left join modfix d on c.noa =d.noa
		where (left(c.code1,1)!='f' and left(c.code1,2)!='sg' and  left(c.code1,2)!='sq') 
				 and d.datea between @t_bdate and @t_edate	
				 and d.mech =@mech
		)
	exec('update #tmp set a'+@j+' ='''+@smount2+''' where seq=5')			
	--合計
	declare @total2 float =@smount1 + @smount2
	exec('update #tmp set a'+@j+' ='''+@total2+''' where seq=6')
--	select @sum1,@sum2,@total,@smount1,@smount2,@total2

---累計-------------------------------------------------------------------------------------------------
	--成型段
	declare @bsum1 float=(
		select sum(c.mount)
		from modout b  left join modouts c on b.noa=c.noa
		where (left(c.code,1)='f' or left(c.code,2)='sg' or  left(c.code,2)='sq')
			and c.datea < @t_bdate 	
			and b.mech = @mech)
		exec('update #tmp set a'+@j+' ='''+@bsum1+''' where seq=7')
	--定徑段
	declare @bsum2 float=(
		select sum(c.mount)
		from modout b  left join modouts c on b.noa=c.noa
		where (left(c.code,1)!='f' and left(c.code,2)!='sg' and  left(c.code,2)!='sq')
			and c.datea < @t_bdate 	
			and b.mech = @mech) 
	exec('update #tmp set a'+@j+' ='''+@bsum2+''' where seq=8')
	--合計
	declare @btotal float = @bsum1+@bsum2
	exec('update #tmp set a'+@j+' ='''+@btotal+''' where seq=9')
	--成行段產量
	declare @bsmount1 float=(
		select sum(c.weight1)
		from modfixs c   left join modfix d on c.noa =d.noa
		where (left(c.code1,1)='f' or left(c.code1,2)='sg' or  left(c.code1,2)='sq' )
				and d.datea between  @t_bdate and @t_edate and d.mech =@mech		
		)	
	exec('update #tmp set a'+@j+' ='''+@bsmount1+''' where seq=10')
	--定俓段產量
	declare @bsmount2 float=(
		select sum(c.weight1)
		from modfixs c   left join modfix d on c.noa =d.noa
		where (left(c.code1,1)!='f' and left(c.code1,2)!='sg' and  left(c.code1,2)!='sq') 
				 and d.datea <=  @t_bdate and d.mech =@mech	
		)
	exec('update #tmp set a'+@j+' ='''+@bsmount2+''' where seq=11')			
	--合計
	declare @btotal2 float =@bsmount1 + @bsmount2
	exec('update #tmp set a'+@j+' ='''+@btotal2+''' where seq=12')	
--	select @bsum1,@bsum2,@btotal,@bsmount1,@bsmount2,@btotal2
	--加班數量
	declare @otime1 float,@addtime1 float,@otime2 float,@addtime2 float
	set @otime1=(select count(isovertime)
	from modcuws b left join modcuw a on a.noa =b.noa
	where isovertime=1 and a.datea between  @t_bdate and @t_edate
		  and a.station = @mech)
	exec('update #tmp set a'+@j+' ='''+@otime1+''' where seq=13')		  
	
	--加班數量累計
	set @addtime1=(select count(isovertime)
	from modcuws b left join modcuw a on a.noa =b.noa
	where isovertime=1 and a.datea <=  @t_bdate 
		  and a.station = @mech)	  
	exec('update #tmp set a'+@j+' ='''+@addtime1+''' where seq=14')  
	--加班工時	  
	set @otime2 =(select sum(addtime)
	from modcuws b left join modcuw a on a.noa =b.noa
	where isovertime=1 and a.datea between @t_bdate and @t_edate
			and a.station = @mech)
	exec('update #tmp set a'+@j+' ='''+@otime2+''' where seq=15') 
	--加班工時累計
	set @addtime2=(select sum(addtime)
	from modcuws b left join modcuw a on a.noa =b.noa
	where isovertime=1 and a.datea <=  @t_bdate
			and a.station = @mech)
	exec('update #tmp set a'+@j+' ='''+@addtime2+''' where seq=16') 		
	--插入機台 第一行
	exec('update #tmp set a'+@j+' ='''+@num+@mech+''' where seq=0') 	
	set @j=@j+1
  fetch next from cursor_table 
  into @mech,@num
end 

CLOSE cursor_table
DEALLOCATE cursor_table
-- update #tmp set gno= seq
 select seq gno,seq,case when seq = 0 then a1 else dbo.getComma(convert(float,a1),0) end a1
		   ,case when seq = 0 then a2 else dbo.getComma(convert(float,a2),0) end a2
		   ,case when seq = 0 then a3 else dbo.getComma(convert(float,a3),0) end a3
		   ,case when seq = 0 then a4 else dbo.getComma(convert(float,a4),0) end a4
		   ,case when seq=0 then '合計' else 
		   dbo.getComma(convert(float,a1)+convert(float,a2)+convert(float,a3)+convert(float,a4),0) end a5
		   ,case when seq = 0 then a4 else dbo.getComma(convert(float,a5),0) end a6
		   ,case when seq = 0 then a5 else dbo.getComma(convert(float,a6),0) end a7
		   ,case when seq=0 then '合計' else 
		   dbo.getComma(convert(float,a5)+convert(float,a6),0) end a8
		   ,case when seq = 0 then a7 else dbo.getComma(convert(float,a7),0) end a9
		   ,case when seq = 0 then a8 else dbo.getComma(convert(float,a8),0) end a10
		   ,case when seq = 0 then a9 else dbo.getComma(convert(float,a9),0) end a11
		   ,case when seq = 0 then a10 else dbo.getComma(convert(float,a10),0) end a12
 from #tmp 
 drop table #tmp
 ;
 
----------------------------------------------------------------------------------------------------
z_modout_rs07:--z_modout_rs07

declare @t_bdate nvarchar(100) 
declare @t_edate nvarchar(100) 
set @t_bdate = case when '#non' = [3] then ''  else [3] end
set @t_edate = case when '#non' = [4] then char(255) else [4] end
---------------------------------------------------------------------------------------------------
IF OBJECT_ID('tempdb..#tmp')is not null
	BEGIN
		drop table #tmp
	END
create table #tmp (
	a1 nvarchar(100),
	a2 nvarchar(100),
	a3 nvarchar(100),
	a4 nvarchar(100),
	a5 nvarchar(100),
	a6 nvarchar(100),
	a7 nvarchar(100),
	a8 nvarchar(100),
	a9 nvarchar(100),
	a10 nvarchar(100),
	seq float
)
declare @i float =0
--左邊行數
declare @rowcount float = 29
while @i <@rowcount
	begin
		insert #tmp(seq)
		select @i
		set @i=@i+1
	end
declare @j float =1

declare @mech nvarchar(100),@num nvarchar(100)
--where datea between @t_bdate and @t_edate 
DECLARE cursor_table CURSOR FOR 
select b.namea,a.device from modeqs b left join modeq a on a.noa=b.noa	order by  b.namea
OPEN cursor_table
FETCH NEXT FROM cursor_table
INTO @mech,@num
WHILE @@FETCH_STATUS = 0
BEGIN


----------------------------------------------------------------------------------------------------
	--成型段
	declare @bsum1 float=(
		select sum(c.mount)
		from modout b  left join modouts c on b.noa=c.noa
		where (left(c.code,1)='f' or left(c.code,2)='sg' or  left(c.code,2)='sq')
			and c.datea < @t_bdate 	
			and b.mech = @mech)
		exec('update #tmp set a'+@j+' ='''+@bsum1+''' where seq=7')
	--定徑段
	declare @bsum2 float=(
		select sum(c.mount)
		from modout b  left join modouts c on b.noa=c.noa
		where (left(c.code,1)!='f' and left(c.code,2)!='sg' and  left(c.code,2)!='sq')
			and c.datea < @t_bdate 	
			and b.mech = @mech) 
	exec('update #tmp set a'+@j+' ='''+@bsum2+''' where seq=8')
	--累計
	declare @btotal float = @bsum1+@bsum2
	exec('update #tmp set a'+@j+' ='''+@btotal+''' where seq=9')
-------------------------------------------------------------------------------------------------
	--成型段產量
	declare @bsmount1 float=(
		select sum(c.weight1)
		from modfixs c   left join modfix d on c.noa =d.noa
		where (left(c.code1,1)='f' or left(c.code1,2)='sg' or  left(c.code1,2)='sq' )
				and d.datea between  @t_bdate and @t_edate and d.mech =@mech		
		)
	exec('update #tmp set a'+@j+' ='''+@bsmount1+''' where seq=10')
	--定俓段產量
	declare @bsmount2 float=(
		select sum(c.weight1)
		from modfixs c   left join modfix d on c.noa =d.noa
		where (left(c.code1,1)!='f' and left(c.code1,2)!='sg' and  left(c.code1,2)!='sq') 
				 and d.datea <=  @t_bdate and d.mech =@mech	
		)
	exec('update #tmp set a'+@j+' ='''+@bsmount2+''' where seq=11')			
	--累計
	declare @btotal2 float =@bsmount1 + @bsmount2
	exec('update #tmp set a'+@j+' ='''+@btotal2+''' where seq=12')	
--	select @bsum1,@bsum2,@btotal,@bsmount1,@bsmount2,@btotal2
	--加班數量	
	declare @otime1 float,@addtime1 float,@otime2 float,@addtime2 float
	set @otime1=(select count(isovertime)
	from modcuws b left join modcuw a on a.noa =b.noa
	where isovertime=1 and a.datea between  @t_bdate and @t_edate
		  and a.station = @mech)
	exec('update #tmp set a'+@j+' ='''+@otime1+''' where seq=13')		  
	--加班數量累計
	set @addtime1=(select count(isovertime)
	from modcuws b left join modcuw a on a.noa =b.noa
	where isovertime=1 and a.datea <=  @t_bdate 
		  and a.station = @mech)	  
	exec('update #tmp set a'+@j+' ='''+@addtime1+''' where seq=14')  
	--加班工時	  
	set @otime2 =(select sum(addtime)
	from modcuws b left join modcuw a on a.noa =b.noa
	where isovertime=1 and a.datea between @t_bdate and @t_edate
			and a.station = @mech)
	exec('update #tmp set a'+@j+' ='''+@otime2+''' where seq=15') 
	--加班工時累計
	set @addtime2=(select sum(addtime)
	from modcuws b left join modcuw a on a.noa =b.noa
	where isovertime=1 and a.datea <=  @t_bdate
			and a.station = @mech)
	exec('update #tmp set a'+@j+' ='''+@addtime2+''' where seq=16') 		
		
	--故障
	declare @faulttime float =(
	select sum(b.faulttime)
	from modcuw a left join modcuws b on a.noa=b.noa 
	where a.datea between  @t_bdate and @t_edate and a.station = @mech)
	exec('update #tmp set a'+@j+' ='''+@faulttime+''' where seq=17') 
	--故障累計
	declare @faulttime1 float =(
	select sum(b.faulttime)
	from modcuw a left join modcuws b on a.noa=b.noa 
	where a.datea <  @t_bdate  and a.station = @mech)
	exec('update #tmp set a'+@j+' ='''+@faulttime1+''' where seq=18') 
	--延遲
	declare @delaytime float =(
		select sum(b.delaytime)
	from modcuw a left join modcuws b on a.noa=b.noa 
	where a.datea between  @t_bdate and @t_edate and a.station = @mech)
	exec('update #tmp set a'+@j+' ='''+@delaytime+''' where seq=19') 
	--延遲累計
	declare @delaytime1 float =(
		select sum(b.delaytime)
	from modcuw a left join modcuws b on a.noa=b.noa 
	where a.datea <=  @t_bdate and a.station = @mech)
	exec('update #tmp set a'+@j+' ='''+@delaytime1+''' where seq=20') 
	--待單
	declare @waittime float=(
	select sum(b.waittime)
	from modcuw a left join modcuws b on a.noa=b.noa 
	where a.datea between  @t_bdate and @t_edate and a.station = @mech)
	exec('update #tmp set a'+@j+' ='''+@waittime+''' where seq=21') 
	--待單累計
	declare @waittime1 float=(
	select sum(b.waittime)
	from modcuw a left join modcuws b on a.noa=b.noa 
	where a.datea <= @t_bdate and a.station = @mech)
	exec('update #tmp set a'+@j+' ='''+@waittime1+''' where seq=22') 
	
	--待料
	declare @waitfedtime float=(
	select sum(b.waitfedtime)
	from modcuw a left join modcuws b on a.noa=b.noa 
	where a.datea between  @t_bdate and @t_edate and a.station = @mech)
	exec('update #tmp set a'+@j+' ='''+@waitfedtime+''' where seq=23') 
	--待料累計
	declare @waitfedtime1 float=(
	select sum(b.waitfedtime)
	from modcuw a left join modcuws b on a.noa=b.noa 
	where a.datea between  @t_bdate and @t_edate and a.station = @mech)
	exec('update #tmp set a'+@j+' ='''+@waitfedtime1+''' where seq=24') 
	--缺員
	declare @lacksss float=(
	select sum(b.lacksss)
	from modcuw a left join modcuws b on a.noa=b.noa 
	where a.datea between  @t_bdate and @t_edate and a.station = @mech)
	exec('update #tmp set a'+@j+' ='''+@lacksss+''' where seq=25') 
	--缺員累計
	declare @lacksss1 float=(
	select sum(b.lacksss)
	from modcuw a left join modcuws b on a.noa=b.noa 
	where a.datea between  @t_bdate and @t_edate and a.station = @mech)
	exec('update #tmp set a'+@j+' ='''+@lacksss1+''' where seq=26') 
	--第一行機台
	exec('update #tmp set a'+@j+' ='''+@num+@mech+''' where seq=6') 
	set @j=@j+1
  fetch next from cursor_table 
  into @mech,@num
end 

CLOSE cursor_table
DEALLOCATE cursor_table
--delete #tmp where ISNULL(a1,'')=''
-- update #tmp set gno= seq
 select seq-6 gno,seq,case when seq = 6 then a1 else dbo.getComma(convert(float,a1),0) end a1
		   ,case when seq = 6 then a2 else dbo.getComma(convert(float,a2),0) end a2
		   ,case when seq = 6 then a3 else dbo.getComma(convert(float,a3),0) end a3
		   ,case when seq = 6 then a4 else dbo.getComma(convert(float,a4),0) end a4
		   ,case when seq = 6 then '合計' else 
		   dbo.getComma(convert(float,a1)+convert(float,a2)+convert(float,a3)+convert(float,a4),0) end a5
		   ,case when seq = 6 then a4 else dbo.getComma(convert(float,a5),0) end a6
		   ,case when seq = 6 then a5 else dbo.getComma(convert(float,a6),0) end a7
		   ,case when seq = 6 then '合計' else 
		   dbo.getComma(convert(float,a5)+convert(float,a6),0) end a8
		   ,case when seq = 6 then a7 else dbo.getComma(convert(float,a7),0) end a9
		   ,case when seq = 6 then a8 else dbo.getComma(convert(float,a8),0) end a10
		   ,case when seq = 6 then a9 else dbo.getComma(convert(float,a9),0) end a11
		   ,case when seq = 6 then a10 else dbo.getComma(convert(float,a10),0) end a12
 from #tmp 
 where seq-6 >=0
 drop table #tmp;
 
z_modout_rs08:--z_modout_rs08
	SET QUOTED_IDENTIFIER OFF
	declare @t_noa nvarchar(30)
	set @t_noa= case when '#non' = [1] then '' else [1] end
------------------------------------------------------------------------------------------------
declare @tmp1 table(
	mech1 nvarchar(50),
	detail nvarchar(100),
	noa nvarchar(30),
	frame nvarchar(30),
	mount float,
	weight float,
	mech2 nvarchar(50),
	mode nvarchar(30),
	memo nvarchar(max),
	seq float
)
--成型段
insert @tmp1(mech1,detail,noa,frame,mount,weight,mech2,memo,seq)
select d.device,b.detail1,b.noa,b.frame1,b.mount1,b.weight1,c.namea,e.memo,ROW_NUMBER() over(order by c.namea)
from modfix a left join modfixs b on a.noa = b.noa
			  left join modeqs c on a.mech = namea
			  left join modeq d on c.noa=d.noa
			  left join modouts e on b.nob=e.nob
where (left(b.code1,1)='F' or left(b.code1,2)='sg' or left(b.code1,2)='sq')
	  and a.modnoa=@t_noa
--update @result
declare @tmp2 table(
	mech1 nvarchar(50),
	detail nvarchar(100),
	noa nvarchar(30),
	frame nvarchar(30),
	mount float,
	weight float,
	mech2 nvarchar(50),
	mode nvarchar(30),
	memo nvarchar(max),
	seq float
)
--定俓段
insert @tmp2(mech1,detail,noa,frame,mount,weight,mech2,seq)
select d.device,b.detail1,b.noa,b.frame1,b.mount1,b.weight1,c.namea,ROW_NUMBER()over(order by c.namea)
from modfix a left join modfixs b on a.noa = b.noa
			  left join modeqs c on a.mech = namea
			  left join modeq d on c.noa=d.noa
			  left join modouts e on b.nob=e.nob
where (left(b.code1,1)!='F' and left(b.code1,2)!='sg' and left(b.code1,2)!='sq')
		and a.modnoa=@t_noa
declare @count float =(select count(*) from @tmp1)	
if(@count < (select count(*) from @tmp2))
	begin
		set @count =  (select count(*) from @tmp2)
	end
declare @i float =1
declare @tmp3 table(seq nvarchar(10))

while(@i<@count)
	begin
		insert @tmp3(seq)
		select @i
		set @i=@i+1
	end



select '0' gno, case when isnull(a.mech1,'')='' then b.mech1 else a.mech1 end mech1,
	a.detail det1,b.detail det2
	,case when isnull(a.noa,'')='' then b.noa else a.noa end noa,a.frame frm1,a.mount mount1,a.weight weight1
	,b.frame frm2,b.mount mount2,b.weight weight2,a.mech2 mech2,a.mode mode,a.memo memo
from @tmp3 c left join @tmp2 b on c.seq=b.seq	
			 left join @tmp1 a on c.seq=b.seq			  
;		 