z_modout_rs01:--z_modout_rs01

SET QUOTED_IDENTIFIER OFF

declare @t_bnoa nvarchar(30)
declare @t_enoa nvarchar(30)

set @t_bnoa= case when '#non' = [1] then '' else [1] end
set @t_enoa= case when '#non' = [2] then char(255) else [2] end
-----------------------------------------------------------------------------
declare @tmp table(
	gno nvarchar(1),
	rec int,
	noa nvarchar(50),
	modnoa nvarchar(50),
	mech nvarchar(40),
	datea nvarchar(50),
	code nvarchar(50),
	detail nvarchar(50),
	frame nvarchar(10),
	mount float
)

insert into @tmp
select '0',ROW_NUMBER()over(partition by a.modnoa order by b.code),a.noa,a.modnoa,a.mech,a.datea,b.code,b.detail,b.frame,SUM(b.mount) from modout a
left join modouts b on a.noa = b.noa
where(a.noa between @t_bnoa and @t_enoa)
group by a.noa,a.modnoa,a.mech,a.datea,b.code,b.detail,b.frame

declare @noa nvarchar(50)
declare @cnt  int
declare @max  int
declare @i    int

declare cursor_table cursor for 
select noa from @tmp group by noa
open cursor_table 
fetch next from cursor_table 
into @noa
while(@@FETCH_STATUS <> -1) 
begin
	set @cnt = (select COUNT(*) from @tmp where noa = @noa)
	set @max = (select MAX(rec) from @tmp where noa = @noa)
	set @i = 0
	while(@i < 25-@cnt%25)
	begin
		insert into @tmp(gno,rec,noa)
		select '0',@max+1,@noa
			
		set @max = @max + 1
		set @i   = @i   + 1
	end
	
	fetch next from cursor_table 
	into @noa
end 
close cursor_table 
deallocate cursor_table

select * from @tmp order by noa,rec;
--**************************************************************************
z_modout_rs02:--z_modout_rs02

SET QUOTED_IDENTIFIER OFF

declare @t_bnoa nvarchar(30)
declare @t_enoa nvarchar(30)

set @t_bnoa= case when '#non' = [3] then '' else [3] end
set @t_enoa= case when '#non' = [4] then char(255) else [4] end
-----------------------------------------------------------------------------
declare @tmp table(
	gno nvarchar(1),
	rec int,
	noa nvarchar(50),
	tgg nvarchar(50),
	datea nvarchar(50),
	usetype nvarchar(50),
	frame nvarchar(50),
	code nvarchar(50),
	detail nvarchar(50),
	class nvarchar(10),
	weight float,
	bebottom float,
	enbottom float,
	way nvarchar(30),
	datea1 nvarchar(50),
	datea2 nvarchar(50),
	times float,
	mount float,
	mech  nvarchar(50),
	worker  nvarchar(10)
)
insert into @tmp(gno,rec,noa,tgg,datea,usetype,frame,code)
select 
	'0',ROW_NUMBER()over(partition by a.noa order by c.nob),a.noa,a.tgg,a.datea,
	case when a.usetype='1' then '設備課' else '製造課' end,a.frame,b.number
from model a
left join models b on a.noa = b.noa
left join modfixs  c on b.productno = c.nob
left join modfixcs  d on b.productno = d.nob
left join modfixcs  e on b.productno = e.nob
where (a.noa between @t_bnoa and @t_enoa)and
	  exists (select * from modfixs  where nob = b.productno)and
	  exists (select * from modfixcs where nob = b.productno)and
	  exists (select * from modouts  where nob = b.productno)
	  
declare @rec int
declare @noa nvarchar(50)
declare @xnoa nvarchar(50) = 'xxxxxx'
declare @code nvarchar(50)

declare cursor_table cursor for 
select noa,code from @tmp group by noa,code
open cursor_table 
fetch next from cursor_table 
into @noa,@code
while(@@FETCH_STATUS <> -1) 
begin
	if(@noa != @xnoa)
	begin
		set @rec = 2
		set @xnoa = @noa
	end	
	
	insert into @tmp(gno,rec,noa,code,detail,class,weight,way,datea1,mount,mech)
	select '1',@rec,@noa,@code,b.detail1,'入庫維修',SUM(b.weight1),b.way1,a.datea,SUM(b.mount1),a.mech 
	from modfix a
	left join modfixs b on a.noa = b.noa
	where(a.modnoa = @noa and b.code1 = @code)
	group by b.way1,a.datea,a.mech,b.detail1
	set @rec = @rec + 1
	
	insert into @tmp(gno,rec,noa,code,detail,class,bebottom,enbottom,way,datea1,datea2,mount,mech,worker)
	select '2',@rec,@noa,@code,b.detail,'維修',MIN(b.bebottom),MIN(b.enbottom),b.way,MIN(b.datea1),MAX(b.datea2),SUM(b.mount),a.mech,b.worker
	from modfixc a
	left join modfixcs b on a.noa = b.noa
	where(a.modnoa = @noa and b.code = @code)
	group by b.detail,b.way,a.mech,b.worker
	set @rec = @rec + 1
	
	insert into @tmp(gno,rec,noa,code,detail,class,enbottom,datea1,mount,mech)
	select '3',@rec,@noa,@code,b.detail,'領用出庫',MIN(c.enbottom),a.datea,SUM(b.mount),a.mech
	from modout a
	left join modouts b on a.noa = b.noa
	left join modfixcs c on b.nob = c.nob
	where(a.modnoa = @noa and b.code = @code)
	group by a.datea,a.mech,b.detail
	set @rec = @rec + 1

	fetch next from cursor_table 
	into @noa,@code
end 
close cursor_table 
deallocate cursor_table 

delete @tmp where gno = '0' and rec != 1

update @tmp set times =
	ROUND((DATEDIFF(minute,CAST(dbo.ChineseEraName2AD(dbo.split(datea1,'-','0'))as nvarchar(20))+' '+dbo.split(datea1,'-','1') ,CAST(dbo.ChineseEraName2AD(dbo.split(datea2,'-','0'))as nvarchar(20))+' '+dbo.split(datea2,'-','1')))/60.0,1)
where gno = '2'

update @tmp set code = noa + code
update @tmp set datea1 = datea1+'<br>(入庫日期)' where gno = '1'
update @tmp set datea1 = dbo.split(datea1,'-',0)+'<br>'+dbo.split(datea1,'-',1)+'<br>(完成起時間)' ,datea2 = dbo.split(datea2,'-',0)+'<br>'+dbo.split(datea2,'-',1)+'<br>(完成訖時間)'where gno = '2'
update @tmp set datea1 = datea1+'<br>(出庫日期)' where gno = '3'

--補空白行(25行)
declare @cnt  int
declare @max  int
declare @i    int

declare cursor_table cursor for 
select noa from @tmp group by noa
open cursor_table 
fetch next from cursor_table 
into @noa
while(@@FETCH_STATUS <> -1) 
begin
	set @cnt = (select COUNT(*) from @tmp where noa = @noa)
	set @max = (select MAX(rec) from @tmp where noa = @noa)
	set @i = 0
	while(@i < 25-@cnt%25)
	begin
		insert into @tmp(gno,rec,noa)
		select '4',@max+1,@noa
			
		set @max = @max + 1
		set @i   = @i   + 1
	end
	
	fetch next from cursor_table 
	into @noa
end 
close cursor_table 
deallocate cursor_table

select * from @tmp order by noa,rec;
--**************************************************************************
z_modout_rs03:--z_modout_rs03

SET QUOTED_IDENTIFIER OFF

declare @t_bnob nvarchar(30)
declare @t_enob nvarchar(30)

set @t_bnob= case when '#non' = [5] then '' else [5] end
set @t_enob= case when '#non' = [6] then char(255) else [6] end
----------------------------------------------------------------------------
declare @tmp table(
	gno nvarchar(1),
	rec int,
	noa nvarchar(50),
	tgg nvarchar(50),
	datea nvarchar(50),
	usetype nvarchar(50),
	frame nvarchar(50),
	nob nvarchar(50),
	detail nvarchar(50),
	class nvarchar(10),
	weight float,
	bebottom float,
	enbottom float,
	way nvarchar(30),
	datea1 nvarchar(50),
	datea2 nvarchar(50),
	times float,
	mount float,
	mech  nvarchar(40),
	worker  nvarchar(10)
)
insert into @tmp(gno,rec,noa,tgg,datea,usetype,frame,nob)
select 
	'0',ROW_NUMBER()over(partition by c.nob order by c.nob),a.noa,a.tgg,a.datea,
	case when a.usetype='1' then '設備課' else '製造課' end,a.frame,c.nob
from model a
left join models b on a.noa = b.noa
left join modfixs  c on b.productno = c.nob
left join modfixcs  d on b.productno = d.nob
left join modfixcs  e on b.productno = e.nob
where (c.nob between @t_bnob and @t_enob)and
	  exists (select * from modfixs  where nob = b.productno)and
	  exists (select * from modfixcs where nob = b.productno)and
	  exists (select * from modouts  where nob = b.productno)

declare @rec int
declare @noa nvarchar(50)
declare @nob nvarchar(50)
declare @xnob nvarchar(50) = 'xxxxxx'
declare @code nvarchar(50)

declare cursor_table cursor for 
select noa,nob from @tmp where gno = '0'
open cursor_table 
fetch next from cursor_table 
into @noa,@nob
while(@@FETCH_STATUS <> -1) 
begin
	if(@nob != @xnob)
	begin
		set @rec = 2
		set @xnob = @nob
	end	
	
	insert into @tmp(gno,rec,noa,nob,detail,class,weight,way,datea1,mount,mech)
	select '1',@rec,@noa,@nob,b.detail1,'入庫維修',b.weight1,b.way1,a.datea,b.mount1,a.mech 
	from modfix a
	left join modfixs b on a.noa = b.noa
	where(b.nob = @nob)
	set @rec = @rec + 1
	
	insert into @tmp(gno,rec,noa,nob,detail,class,bebottom,enbottom,way,datea1,datea2,mount,mech,worker)
	select '2',@rec,@noa,@nob,b.detail,'維修',b.bebottom,b.enbottom,b.way,b.datea1,b.datea2,b.mount,a.mech,b.worker
	from modfixc a
	left join modfixcs b on a.noa = b.noa
	where(b.nob = @nob)
	set @rec = @rec + 1
	
	insert into @tmp(gno,rec,noa,nob,detail,class,enbottom,datea1,mount,mech)
	select '3',@rec,@noa,@nob,b.detail,'領用出庫',c.enbottom,a.datea,b.mount,a.mech
	from modout a
	left join modouts b on a.noa = b.noa
	left join modfixcs c on b.nob = c.nob
	where(b.nob = @nob)
	set @rec = @rec + 1
	

	fetch next from cursor_table 
	into @noa,@nob
end 
close cursor_table 
deallocate cursor_table 


update @tmp set times =
	ROUND((DATEDIFF(minute,CAST(dbo.ChineseEraName2AD(dbo.split(datea1,'-','0'))as nvarchar(20))+' '+dbo.split(datea1,'-','1') ,CAST(dbo.ChineseEraName2AD(dbo.split(datea2,'-','0'))as nvarchar(20))+' '+dbo.split(datea2,'-','1')))/60.0,1)
where gno = '2'

update @tmp set datea1 = datea1+'<br>(入庫日期)' where gno = '1'
update @tmp set datea1 = dbo.split(datea1,'-',0)+'<br>'+dbo.split(datea1,'-',1)+'<br>(完成起時間)' ,datea2 = dbo.split(datea2,'-',0)+'<br>'+dbo.split(datea2,'-',1)+'<br>(完成訖時間)'where gno = '2'
update @tmp set datea1 = datea1+'<br>(出庫日期)' where gno = '3'

--補空白行(25行)
declare @cnt  int
declare @max  int
declare @i    int

declare cursor_table cursor for 
select nob from @tmp group by nob
open cursor_table 
fetch next from cursor_table 
into @nob
while(@@FETCH_STATUS <> -1) 
begin
	set @cnt = (select COUNT(*) from @tmp where nob = @nob)
	set @max = (select MAX(rec) from @tmp where nob = @nob)
	set @i = 0
	while(@i < 25-@cnt%25)
	begin
		insert into @tmp(gno,rec,nob)
		select '4',@max+1,@nob
			
		set @max = @max + 1
		set @i   = @i   + 1
	end
	
	fetch next from cursor_table 
	into @nob
end 
close cursor_table 
deallocate cursor_table

select * from  @tmp order by nob,rec;
--**************************************************************************
z_modout_rs04:--z_modout_rs04

declare @t_bdate nvarchar(20)
declare @t_edate nvarchar(20)
declare @t_worker nvarchar(100)

set @t_bdate = case when '#non' = [7] then ''  else [7] end
set @t_edate = case when '#non' = [8] then char(255) else [8] end
set @t_worker = case when '#non' = [9] then '' else [9] end
----------------------------------------------------------------------------
declare @tmp table(
	gno nvarchar(1),
	rec int,
	datea nvarchar(20),
	worker nvarchar(50),
	noa nvarchar(50),
	detail nvarchar(50),
	class nvarchar(50),
	mech nvarchar(40),
	weight float,
	bebottom float,
	enbottom float,
	way nvarchar(30),
	b2edate nvarchar(50),
	mount float
	
)
insert into @tmp
select 
	'1',ROW_NUMBER()over(partition by a.datea order by b.worker),a.datea,b.worker,a.modnoa+b.code,
	b.detail,'維修',a.mech,SUM(c.weight1),MIN(b.bebottom),MIN(b.enbottom),b.way,MIN(b.datea1)+'~'+MAX(b.datea2),SUM(b.mount)
from modfixc a
left join modfixcs b on a.noa = b.noa
left join modfixs  c on b.nob = c.nob
where(a.datea between @t_bdate and @t_edate) and (@t_worker = '' or b.worker = @t_worker)
group by a.datea,b.worker,a.modnoa+b.code,b.detail,a.mech,b.way

--補空白行(25行)
declare @datea  nvarchar(50)
declare @cnt  int
declare @max  int
declare @i    int

declare cursor_table cursor for 
select datea from @tmp group by datea
open cursor_table 
fetch next from cursor_table 
into @datea
while(@@FETCH_STATUS <> -1) 
begin
	set @cnt = (select COUNT(*) from @tmp where datea = @datea)
	set @max = (select MAX(rec) from @tmp where datea = @datea)
	set @i = 0
	while(@i < 25-@cnt%25)
	begin
		insert into @tmp(gno,rec,datea)
		select '2',@max+1,@datea
			
		set @max = @max + 1
		set @i   = @i   + 1
	end
	
	fetch next from cursor_table 
	into @datea
end 
close cursor_table 
deallocate cursor_table

select * from @tmp order by datea,rec;
--**************************************************************************
z_modout_rs05:--z_modout_rs05

declare @t_bmodnoa nvarchar(50)
declare @t_emodnoa nvarchar(50)
declare @t_bframe nvarchar(50)
declare @t_eframe nvarchar(50)

set @t_bmodnoa= case when '#non' = [3] then '' else [3] end
set @t_emodnoa= case when '#non' = [4] then char(255) else [4] end
set @t_bframe = case when '#non' = [10] then '' else [10] end
set @t_eframe = case when '#non' = [11] then char(255) else [11] end
----------------------------------------------------------------------------
declare @tmp table(
	gno nvarchar(1),
	rec int,
	modnoa nvarchar(50),
	frame nvarchar(30),
	noa nvarchar(50),
	detail nvarchar(50),
	class nvarchar(50),
	mech nvarchar(40),
	weight float,
	way nvarchar(30),
	mount float
	
)
insert into @tmp
select 
	'1',ROW_NUMBER()over(partition by a.modnoa order by a.modnoa+b.code1),a.modnoa,b.frame1,a.modnoa+b.code1,
	b.detail1,'入庫維修',a.mech,SUM(b.weight1),b.way1,SUM(b.mount1)
from modfix a
left join modfixs b on a.noa = b.noa
where(a.modnoa between @t_bmodnoa and @t_emodnoa) and (b.frame1 between @t_bframe and @t_eframe) and
	 not exists (select * from modfixcs where nob = b.nob)
group by a.modnoa,b.frame1,a.modnoa+b.code1,b.detail1,a.mech,b.way1

--補空白行(25行)
declare @modnoa  nvarchar(50)
declare @cnt  int
declare @max  int
declare @i    int

declare cursor_table cursor for 
select modnoa from @tmp group by modnoa
open cursor_table 
fetch next from cursor_table 
into @modnoa
while(@@FETCH_STATUS <> -1) 
begin
	set @cnt = (select COUNT(*) from @tmp where modnoa = @modnoa)
	set @max = (select MAX(rec) from @tmp where modnoa = @modnoa)
	set @i = 0
	while(@i < 25-@cnt%25)
	begin
		insert into @tmp(gno,rec,modnoa)
		select '2',@max+1,@modnoa
			
		set @max = @max + 1
		set @i   = @i   + 1
	end
	
	fetch next from cursor_table 
	into @modnoa
end 
close cursor_table 
deallocate cursor_table

select * from @tmp order by modnoa,rec;
--**************************************************************************
z_modout_rs06:--z_modout_rs06

declare @t_bdate nvarchar(100) 
declare @t_edate nvarchar(100) 
set @t_bdate = case when '#non' = [7] then ''  else [7] end
set @t_edate = case when '#non' = [8] then char(255) else [8] end
----------------------------------------------------------------------------
IF OBJECT_ID('tempdb..#tmp')is not null
	BEGIN
		drop table #tmp
	END
create table #tmp (
	a1 nvarchar(100),
	a2 nvarchar(100),
	a3 nvarchar(100),
	a4 nvarchar(100),
	a5 nvarchar(100),
	a6 nvarchar(100),
	a7 nvarchar(100),
	a8 nvarchar(100),
	a9 nvarchar(100),
	a10 nvarchar(100),
	seq float
	
)
--左邊行數
declare @rowcount float=19
declare @i float =0

while @i < @rowcount
	begin
		insert #tmp(seq)
		select @i
		set @i=@i+1
	end
declare @j float =1

declare @mech nvarchar(100),@num nvarchar(100)
--where datea between @t_bdate and @t_edate 
DECLARE cursor_table CURSOR FOR 
select b.namea,a.device from modeqs b left join modeq a on a.noa=b.noa	order by  b.namea
OPEN cursor_table
FETCH NEXT FROM cursor_table
INTO @mech,@num
WHILE @@FETCH_STATUS = 0
BEGIN
------本日-------------------------------------------------------------------
	--成型段 
	declare @sum1 float=(
	select sum(c.mount)
	from  modout b  left join modouts c on b.noa=c.noa
	where (left(c.code,1)='f' or left(c.code,2)='sg' or  left(c.code,2)='sq')
			and c.datea between @t_bdate and @t_edate  and b.mech = @mech)
	exec('update #tmp set a'+@j+' ='''+@sum1+''' where seq=1')
	--定徑段 
	declare @sum2 float=(
	select sum(c.mount)
	from  modout b  left join modouts c on b.noa=c.noa
	where (left(c.code,1)!='f' and left(c.code,2)!='sg' and  left(c.code,2)!='sq')
			and c.datea between @t_bdate and @t_edate
			and b.mech =@mech
	 		) 
	exec('update #tmp set a'+@j+' ='''+@sum2+''' where seq=2')
	declare @total float = @sum1+@sum2
	--合計
	exec('update #tmp set a'+@j+' ='''+@total+''' where seq=3')
	--成型段產量
	declare @smount1 float=(
		select sum(c.weight1)
		from  modfixs c   left join modfix d on c.noa =d.noa
		where (left(c.code1,1)='f' or left(c.code1,2)='sg' or  left(c.code1,2)='sq' )
				and d.datea between @t_bdate and @t_edate
				and d.mech =@mech		
		)
	exec('update #tmp set a'+@j+' ='''+@smount1+''' where seq=4')
	
	--定俓段產量
	declare @smount2 float=(
		select sum(c.weight1)
		from  modfixs c   left join modfix d on c.noa =d.noa
		where (left(c.code1,1)!='f' and left(c.code1,2)!='sg' and  left(c.code1,2)!='sq') 
				 and d.datea between @t_bdate and @t_edate	
				 and d.mech =@mech
		)
	exec('update #tmp set a'+@j+' ='''+@smount2+''' where seq=5')			
	--合計
	declare @total2 float =@smount1 + @smount2
	exec('update #tmp set a'+@j+' ='''+@total2+''' where seq=6')
--	select @sum1,@sum2,@total,@smount1,@smount2,@total2

---累計-------------------------------------------------------------------------------------------------
	--成型段
	declare @bsum1 float=(
		select sum(c.mount)
		from modout b  left join modouts c on b.noa=c.noa
		where (left(c.code,1)='f' or left(c.code,2)='sg' or  left(c.code,2)='sq')
			and c.datea < @t_bdate 	
			and b.mech = @mech)
		exec('update #tmp set a'+@j+' ='''+@bsum1+''' where seq=7')
	--定徑段
	declare @bsum2 float=(
		select sum(c.mount)
		from modout b  left join modouts c on b.noa=c.noa
		where (left(c.code,1)!='f' and left(c.code,2)!='sg' and  left(c.code,2)!='sq')
			and c.datea < @t_bdate 	
			and b.mech = @mech) 
	exec('update #tmp set a'+@j+' ='''+@bsum2+''' where seq=8')
	--合計
	declare @btotal float = @bsum1+@bsum2
	exec('update #tmp set a'+@j+' ='''+@btotal+''' where seq=9')
	--成行段產量
	declare @bsmount1 float=(
		select sum(c.weight1)
		from modfixs c   left join modfix d on c.noa =d.noa
		where (left(c.code1,1)='f' or left(c.code1,2)='sg' or  left(c.code1,2)='sq' )
				and d.datea between  @t_bdate and @t_edate and d.mech =@mech		
		)	
	exec('update #tmp set a'+@j+' ='''+@bsmount1+''' where seq=10')
	--定俓段產量
	declare @bsmount2 float=(
		select sum(c.weight1)
		from modfixs c   left join modfix d on c.noa =d.noa
		where (left(c.code1,1)!='f' and left(c.code1,2)!='sg' and  left(c.code1,2)!='sq') 
				 and d.datea <=  @t_bdate and d.mech =@mech	
		)
	exec('update #tmp set a'+@j+' ='''+@bsmount2+''' where seq=11')			
	--合計
	declare @btotal2 float =@bsmount1 + @bsmount2
	exec('update #tmp set a'+@j+' ='''+@btotal2+''' where seq=12')	
--	select @bsum1,@bsum2,@btotal,@bsmount1,@bsmount2,@btotal2
	--加班數量
	declare @otime1 float,@addtime1 float,@otime2 float,@addtime2 float
	set @otime1=(select count(isovertime)
	from modcuws b left join modcuw a on a.noa =b.noa
	where isovertime=1 and a.datea between  @t_bdate and @t_edate
		  and a.station = @mech)
	exec('update #tmp set a'+@j+' ='''+@otime1+''' where seq=13')		  
	
	--加班數量累計
	set @addtime1=(select count(isovertime)
	from modcuws b left join modcuw a on a.noa =b.noa
	where isovertime=1 and a.datea <=  @t_bdate 
		  and a.station = @mech)	  
	exec('update #tmp set a'+@j+' ='''+@addtime1+''' where seq=14')  
	--加班工時	  
	set @otime2 =(select sum(addtime)
	from modcuws b left join modcuw a on a.noa =b.noa
	where isovertime=1 and a.datea between @t_bdate and @t_edate
			and a.station = @mech)
	exec('update #tmp set a'+@j+' ='''+@otime2+''' where seq=15') 
	--加班工時累計
	set @addtime2=(select sum(addtime)
	from modcuws b left join modcuw a on a.noa =b.noa
	where isovertime=1 and a.datea <=  @t_bdate
			and a.station = @mech)
	exec('update #tmp set a'+@j+' ='''+@addtime2+''' where seq=16') 		
	--插入機台 第一行
	exec('update #tmp set a'+@j+' ='''+@num+@mech+''' where seq=0') 	
	set @j=@j+1
  fetch next from cursor_table 
  into @mech,@num
end 

CLOSE cursor_table
DEALLOCATE cursor_table
-- update #tmp set gno= seq
 select seq gno,seq,case when seq = 0 then a1 else dbo.getComma(convert(float,a1),0) end a1
		   ,case when seq = 0 then a2 else dbo.getComma(convert(float,a2),0) end a2
		   ,case when seq = 0 then a3 else dbo.getComma(convert(float,a3),0) end a3
		   ,case when seq = 0 then a4 else dbo.getComma(convert(float,a4),0) end a4
		   ,case when seq=0 then '合計' else 
		   dbo.getComma(convert(float,a1)+convert(float,a2)+convert(float,a3)+convert(float,a4),0) end a5
		   ,case when seq = 0 then a4 else dbo.getComma(convert(float,a5),0) end a6
		   ,case when seq = 0 then a5 else dbo.getComma(convert(float,a6),0) end a7
		   ,case when seq=0 then '合計' else 
		   dbo.getComma(convert(float,a5)+convert(float,a6),0) end a8
		   ,case when seq = 0 then a7 else dbo.getComma(convert(float,a7),0) end a9
		   ,case when seq = 0 then a8 else dbo.getComma(convert(float,a8),0) end a10
		   ,case when seq = 0 then a9 else dbo.getComma(convert(float,a9),0) end a11
		   ,case when seq = 0 then a10 else dbo.getComma(convert(float,a10),0) end a12
 from #tmp 
 drop table #tmp
 ;
 --**************************************************************************
z_modout_rs07:--z_modout_rs07

SET QUOTED_IDENTIFIER OFF

declare @t_bmodnoa nvarchar(50)
declare @t_emodnoa nvarchar(50)

set @t_bmodnoa = case when '#non' = [3] then '' else [3] end
set @t_emodnoa = case when '#non' = [4] then char(255) else [4] end
----------------------------------------------------------------------------
declare @tmp1 table(
	mech1 nvarchar(50),
	detail nvarchar(100),
	noa nvarchar(30),
	frame nvarchar(30),
	mount float,
	weight float,
	mech2 nvarchar(50),
	mode nvarchar(30),
	memo nvarchar(max),
	seq float
)
--成型段
insert @tmp1(mech1,detail,noa,frame,mount,weight,mech2,memo,seq)
select d.device,b.detail1,b.noa,b.frame1,b.mount1,b.weight1,c.namea,e.memo,ROW_NUMBER() over(order by c.namea)
from modfix a left join modfixs b on a.noa = b.noa
			  left join modeqs c on a.mech = namea
			  left join modeq d on c.noa=d.noa
			  left join modouts e on b.nob=e.nob
where (left(b.code1,1)='F' or left(b.code1,2)='sg' or left(b.code1,2)='sq')
	  and (a.modnoa between @t_bmodnoa and @t_emodnoa)
--update @result
declare @tmp2 table(
	mech1 nvarchar(50),
	detail nvarchar(100),
	noa nvarchar(30),
	frame nvarchar(30),
	mount float,
	weight float,
	mech2 nvarchar(50),
	mode nvarchar(30),
	memo nvarchar(max),
	seq float
)
--定俓段
insert @tmp2(mech1,detail,noa,frame,mount,weight,mech2,seq)
select d.device,b.detail1,b.noa,b.frame1,b.mount1,b.weight1,c.namea,ROW_NUMBER()over(order by c.namea)
from modfix a left join modfixs b on a.noa = b.noa
			  left join modeqs c on a.mech = namea
			  left join modeq d on c.noa=d.noa
			  left join modouts e on b.nob=e.nob
where (left(b.code1,1)!='F' and left(b.code1,2)!='sg' and left(b.code1,2)!='sq')
		and (a.modnoa between @t_bmodnoa and @t_emodnoa)
declare @count float =(select count(*) from @tmp1)	
if(@count < (select count(*) from @tmp2))
	begin
		set @count =  (select count(*) from @tmp2)
	end
declare @i float =1
declare @tmp3 table(seq nvarchar(10))

while(@i<@count)
	begin
		insert @tmp3(seq)
		select @i
		set @i=@i+1
	end



select '0' gno, case when isnull(a.mech1,'')='' then b.mech1 else a.mech1 end mech1,
	a.detail det1,b.detail det2
	,case when isnull(a.noa,'')='' then b.noa else a.noa end noa,a.frame frm1,a.mount mount1,a.weight weight1
	,b.frame frm2,b.mount mount2,b.weight weight2,a.mech2 mech2,a.mode mode,a.memo memo
from @tmp3 c left join @tmp2 b on c.seq=b.seq	
			 left join @tmp1 a on c.seq=b.seq			  
;	
--**************************************************************************
z_modout_rs08:--z_modout_rs08

declare @t_bdate nvarchar(100) 
declare @t_edate nvarchar(100) 
set @t_bdate = case when '#non' = [7] then ''  else [7] end
set @t_edate = case when '#non' = [8] then char(255) else [8] end
-----------------------------------------------------------------------------
IF OBJECT_ID('tempdb..#tmp')is not null
	BEGIN
		drop table #tmp
	END
create table #tmp (
	a1 nvarchar(100),
	a2 nvarchar(100),
	a3 nvarchar(100),
	a4 nvarchar(100),
	a5 nvarchar(100),
	a6 nvarchar(100),
	a7 nvarchar(100),
	a8 nvarchar(100),
	a9 nvarchar(100),
	a10 nvarchar(100),
	seq float
)
declare @i float =0
--左邊行數
declare @rowcount float = 29
while @i <@rowcount
	begin
		insert #tmp(seq)
		select @i
		set @i=@i+1
	end
declare @j float =1

declare @mech nvarchar(100),@num nvarchar(100)
--where datea between @t_bdate and @t_edate 
DECLARE cursor_table CURSOR FOR 
select b.namea,a.device from modeqs b left join modeq a on a.noa=b.noa	order by  b.namea
OPEN cursor_table
FETCH NEXT FROM cursor_table
INTO @mech,@num
WHILE @@FETCH_STATUS = 0
BEGIN


----------------------------------------------------------------------------------------------------
	--成型段
	declare @bsum1 float=(
		select sum(c.mount)
		from modout b  left join modouts c on b.noa=c.noa
		where (left(c.code,1)='f' or left(c.code,2)='sg' or  left(c.code,2)='sq')
			and c.datea < @t_bdate 	
			and b.mech = @mech)
		exec('update #tmp set a'+@j+' ='''+@bsum1+''' where seq=7')
	--定徑段
	declare @bsum2 float=(
		select sum(c.mount)
		from modout b  left join modouts c on b.noa=c.noa
		where (left(c.code,1)!='f' and left(c.code,2)!='sg' and  left(c.code,2)!='sq')
			and c.datea < @t_bdate 	
			and b.mech = @mech) 
	exec('update #tmp set a'+@j+' ='''+@bsum2+''' where seq=8')
	--累計
	declare @btotal float = @bsum1+@bsum2
	exec('update #tmp set a'+@j+' ='''+@btotal+''' where seq=9')
-------------------------------------------------------------------------------------------------
	--成型段產量
	declare @bsmount1 float=(
		select sum(c.weight1)
		from modfixs c   left join modfix d on c.noa =d.noa
		where (left(c.code1,1)='f' or left(c.code1,2)='sg' or  left(c.code1,2)='sq' )
				and d.datea between  @t_bdate and @t_edate and d.mech =@mech		
		)
	exec('update #tmp set a'+@j+' ='''+@bsmount1+''' where seq=10')
	--定俓段產量
	declare @bsmount2 float=(
		select sum(c.weight1)
		from modfixs c   left join modfix d on c.noa =d.noa
		where (left(c.code1,1)!='f' and left(c.code1,2)!='sg' and  left(c.code1,2)!='sq') 
				 and d.datea <=  @t_bdate and d.mech =@mech	
		)
	exec('update #tmp set a'+@j+' ='''+@bsmount2+''' where seq=11')			
	--累計
	declare @btotal2 float =@bsmount1 + @bsmount2
	exec('update #tmp set a'+@j+' ='''+@btotal2+''' where seq=12')	
--	select @bsum1,@bsum2,@btotal,@bsmount1,@bsmount2,@btotal2
	--加班數量	
	declare @otime1 float,@addtime1 float,@otime2 float,@addtime2 float
	set @otime1=(select count(isovertime)
	from modcuws b left join modcuw a on a.noa =b.noa
	where isovertime=1 and a.datea between  @t_bdate and @t_edate
		  and a.station = @mech)
	exec('update #tmp set a'+@j+' ='''+@otime1+''' where seq=13')		  
	--加班數量累計
	set @addtime1=(select count(isovertime)
	from modcuws b left join modcuw a on a.noa =b.noa
	where isovertime=1 and a.datea <=  @t_bdate 
		  and a.station = @mech)	  
	exec('update #tmp set a'+@j+' ='''+@addtime1+''' where seq=14')  
	--加班工時	  
	set @otime2 =(select sum(addtime)
	from modcuws b left join modcuw a on a.noa =b.noa
	where isovertime=1 and a.datea between @t_bdate and @t_edate
			and a.station = @mech)
	exec('update #tmp set a'+@j+' ='''+@otime2+''' where seq=15') 
	--加班工時累計
	set @addtime2=(select sum(addtime)
	from modcuws b left join modcuw a on a.noa =b.noa
	where isovertime=1 and a.datea <=  @t_bdate
			and a.station = @mech)
	exec('update #tmp set a'+@j+' ='''+@addtime2+''' where seq=16') 		
		
	--故障
	declare @faulttime float =(
	select sum(b.faulttime)
	from modcuw a left join modcuws b on a.noa=b.noa 
	where a.datea between  @t_bdate and @t_edate and a.station = @mech)
	exec('update #tmp set a'+@j+' ='''+@faulttime+''' where seq=17') 
	--故障累計
	declare @faulttime1 float =(
	select sum(b.faulttime)
	from modcuw a left join modcuws b on a.noa=b.noa 
	where a.datea <  @t_bdate  and a.station = @mech)
	exec('update #tmp set a'+@j+' ='''+@faulttime1+''' where seq=18') 
	--延遲
	declare @delaytime float =(
		select sum(b.delaytime)
	from modcuw a left join modcuws b on a.noa=b.noa 
	where a.datea between  @t_bdate and @t_edate and a.station = @mech)
	exec('update #tmp set a'+@j+' ='''+@delaytime+''' where seq=19') 
	--延遲累計
	declare @delaytime1 float =(
		select sum(b.delaytime)
	from modcuw a left join modcuws b on a.noa=b.noa 
	where a.datea <=  @t_bdate and a.station = @mech)
	exec('update #tmp set a'+@j+' ='''+@delaytime1+''' where seq=20') 
	--待單
	declare @waittime float=(
	select sum(b.waittime)
	from modcuw a left join modcuws b on a.noa=b.noa 
	where a.datea between  @t_bdate and @t_edate and a.station = @mech)
	exec('update #tmp set a'+@j+' ='''+@waittime+''' where seq=21') 
	--待單累計
	declare @waittime1 float=(
	select sum(b.waittime)
	from modcuw a left join modcuws b on a.noa=b.noa 
	where a.datea <= @t_bdate and a.station = @mech)
	exec('update #tmp set a'+@j+' ='''+@waittime1+''' where seq=22') 
	
	--待料
	declare @waitfedtime float=(
	select sum(b.waitfedtime)
	from modcuw a left join modcuws b on a.noa=b.noa 
	where a.datea between  @t_bdate and @t_edate and a.station = @mech)
	exec('update #tmp set a'+@j+' ='''+@waitfedtime+''' where seq=23') 
	--待料累計
	declare @waitfedtime1 float=(
	select sum(b.waitfedtime)
	from modcuw a left join modcuws b on a.noa=b.noa 
	where a.datea between  @t_bdate and @t_edate and a.station = @mech)
	exec('update #tmp set a'+@j+' ='''+@waitfedtime1+''' where seq=24') 
	--缺員
	declare @lacksss float=(
	select sum(b.lacksss)
	from modcuw a left join modcuws b on a.noa=b.noa 
	where a.datea between  @t_bdate and @t_edate and a.station = @mech)
	exec('update #tmp set a'+@j+' ='''+@lacksss+''' where seq=25') 
	--缺員累計
	declare @lacksss1 float=(
	select sum(b.lacksss)
	from modcuw a left join modcuws b on a.noa=b.noa 
	where a.datea between  @t_bdate and @t_edate and a.station = @mech)
	exec('update #tmp set a'+@j+' ='''+@lacksss1+''' where seq=26') 
	--第一行機台
	exec('update #tmp set a'+@j+' ='''+@num+@mech+''' where seq=6') 
	set @j=@j+1
  fetch next from cursor_table 
  into @mech,@num
end 

CLOSE cursor_table
DEALLOCATE cursor_table
--delete #tmp where ISNULL(a1,'')=''
-- update #tmp set gno= seq
 select seq-6 gno,seq,case when seq = 6 then a1 else dbo.getComma(convert(float,a1),0) end a1
		   ,case when seq = 6 then a2 else dbo.getComma(convert(float,a2),0) end a2
		   ,case when seq = 6 then a3 else dbo.getComma(convert(float,a3),0) end a3
		   ,case when seq = 6 then a4 else dbo.getComma(convert(float,a4),0) end a4
		   ,case when seq = 6 then '合計' else 
		   dbo.getComma(convert(float,a1)+convert(float,a2)+convert(float,a3)+convert(float,a4),0) end a5
		   ,case when seq = 6 then a4 else dbo.getComma(convert(float,a5),0) end a6
		   ,case when seq = 6 then a5 else dbo.getComma(convert(float,a6),0) end a7
		   ,case when seq = 6 then '合計' else 
		   dbo.getComma(convert(float,a5)+convert(float,a6),0) end a8
		   ,case when seq = 6 then a7 else dbo.getComma(convert(float,a7),0) end a9
		   ,case when seq = 6 then a8 else dbo.getComma(convert(float,a8),0) end a10
		   ,case when seq = 6 then a9 else dbo.getComma(convert(float,a9),0) end a11
		   ,case when seq = 6 then a10 else dbo.getComma(convert(float,a10),0) end a12
 from #tmp 
 where seq-6 >=0
 drop table #tmp;
	 