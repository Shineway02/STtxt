z_modfixc_rs01:--z_modfixc_rs01

SET QUOTED_IDENTIFIER OFF
	
declare @t_bnoa nvarchar(30)
declare @t_enoa nvarchar(30)

set @t_bnoa= case when '#non' = [1] then '' else [1] end
set @t_enoa= case when '#non' = [2] then CHAR(255) else [2] end
---------------------------------------------------------------
declare @tmp table(
	gno nvarchar(1),
	rec int,
	noa nvarchar(30),
	modnoa nvarchar(50),
	mech nvarchar(40),
	code nvarchar(50),
	detail nvarchar(50),
	frame nvarchar(1),
	mount float,
	way nvarchar(30),
	bebottom float,
	enbottom float,
	bdatea nvarchar(20),
	edatea nvarchar(20),
	worker nvarchar(50)
)
insert into @tmp
select 
	'0',ROW_NUMBER()over(partition by a.modnoa order by b.code),a.noa,a.modnoa,a.mech,b.code,b.detail,b.frame,SUM(b.mount),b.way,MIN(b.bebottom),MIN(b.enbottom),
	MIN(REPLACE(b.datea1,'-',' ')),MAX(REPLACE(b.datea2,'-',' ')),b.worker
from modfixc a
left join modfixcs b on a.noa = b.noa
where(a.noa between @t_bnoa and @t_enoa)
group by  a.noa,a.modnoa,a.mech,b.code,b.detail,b.frame,b.way,b.worker

declare @noa nvarchar(50)
declare @cnt  int
declare @max  int
declare @i    int

declare cursor_table cursor for 
select noa from @tmp group by noa
open cursor_table 
fetch next from cursor_table 
into @noa
while(@@FETCH_STATUS <> -1) 
begin
	set @cnt = (select COUNT(*) from @tmp where noa = @noa)
	set @max = (select MAX(rec) from @tmp where noa = @noa)
	set @i = 0
	while(@i < 25-@cnt%25)
	begin
		insert into @tmp(gno,rec,noa)
		select '0',@max+1,@noa
			
		set @max = @max + 1
		set @i   = @i   + 1
	end
	
	fetch next from cursor_table 
	into @noa
end 
close cursor_table 
deallocate cursor_table 

select * from @tmp order by noa,rec;
--****************************************************************
z_modfixc_rs02:--z_modfixc_rs02
declare @t_bdate nvarchar(20)
declare @t_edate nvarchar(20)

set @t_bdate = case when '#non' = [3] then ''  else [3] end
set @t_edate = case when '#non' = [4] then char(255) else [4] end
-------------------------------------------------------------------
declare @count float = (select count(distinct namea) from modeqs) 
declare @date1 datetime 
	set @date1= (select convert(datetime,replace(convert(nvarchar,(convert(float,left(@t_bdate ,3))+1911))+SUBSTRING(@t_bdate,4,20),'-',' ')))
declare @date2 datetime = (select convert(datetime,replace(convert(nvarchar,(convert(float,left(@t_edate ,3))+1911))+SUBSTRING(@t_edate,4,20),'-',' ')))
declare @datecount float =(select convert(float,DATEDIFF(day,@date1,@date2)))
declare @j float =1, @k float =0


IF OBJECT_ID('tempdb..#result')is not null
	BEGIN
		drop table #result
	END
	
	
create table #result (datea nvarchar(50),
					  a1 nvarchar(max),
					  a2 nvarchar(max),
					  a3 nvarchar(max),
					  a4 nvarchar(max),
					  a5 nvarchar(max),
					  a6 nvarchar(max),
					  a7 nvarchar(max),
					  a8 nvarchar(max),
					  a9 nvarchar(max),
					  a10 nvarchar(max),
					  seq float,
					  gno nvarchar(1))

--插入左方日期欄位
while (@k <= @datecount)
	begin
		
		exec('	declare  @day'+@j+' nvarchar(100)
				set @day'+@j+' =
				convert(nvarchar,year(dateadd(day,'+@k+','''+@date1+'''))-1911)
				+''/''+
				case when convert(nvarchar,month(dateadd(day,'+@k+','''+@date1+''')))
				< 10 then ''0''+ convert(nvarchar,month(dateadd(day,'+@k+','''+@date1+''')))
				else convert(nvarchar,month(dateadd(day,'+@k+','''+@date1+'''))) end
				+''/''+
				case when convert(nvarchar,day(dateadd(day,'+@k+','''+@date1+''')))
				< 10 then ''0''+ convert(nvarchar,day(dateadd(day,'+@k+','''+@date1+''')))
				else convert(nvarchar,day(dateadd(day,'+@k+','''+@date1+'''))) end
				insert #result(datea,seq)
				select @day'+@j+','+@j+'
				
				')
		set @j=@j+1
		set @k=@k+1
		
	end	


--插入上方行機台
declare @tmp table( namea nvarchar(100),mech nvarchar(50),tgg nvarchar(50),seq float)
insert @tmp
select  a.device,b.namea,b.tgg,ROW_NUMBER() over(order by datea) 
from modeqs b left join modeq a on a.noa=b.noa
						
declare @mech nvarchar(50),
		@tgg nvarchar(50), @cmd nvarchar(50),@pre nvarchar(50)=''
		,@bmech nvarchar(max),@datea nvarchar(max),@namea nvarchar(max)
	

insert #result(datea)
select '000#000'
if(@count > 0 )
	begin
	--依日期插入資料				
		DECLARE my_cursor CURSOR FOR 
		select datea from #result 
		OPEN my_cursor
		FETCH NEXT FROM my_cursor 
		INTO @datea
		WHILE @@FETCH_STATUS = 0
		BEGIN
			declare @l float =1
			set @bmech=@mech+@tgg
			--依機台插入資料
			DECLARE cursor2 CURSOR FOR 
			select mech,tgg,namea from @tmp order by mech
			OPEN cursor2
			FETCH NEXT FROM cursor2
			INTO @mech,@tgg,@namea
			WHILE @@FETCH_STATUS = 0
			BEGIN	
							
				set @cmd=(select max(c.spec)+' '+convert(nvarchar,sum(b.mount))
						 +' '+max(a.mech)
						 +' '+max(b.worker)
				from modfixcs b left join modfixc a on a.noa=b.noa
							left join model c on  a.modnoa=c.noa
				where @datea =a.datea  and a.mech=@mech)
				
				exec('update #result set a'+@l+' = '''+@cmd+ '''
					  where datea='''+@datea+'''')
				exec('update #result set a'+@l+' = '''+@namea+' '+@tgg+ '''
					  where datea=''000#000''')
			set @l =@l+1			
			
			fetch next from cursor2 
			into @mech,@tgg,@namea
			end 
		
		CLOSE cursor2
		DEALLOCATE cursor2
			
			
		fetch next from my_cursor 
		into @datea
		end 
		
		CLOSE my_cursor
		DEALLOCATE my_cursor
			
					
	end
insert #result(gno)
select '1'
select case when gno is null then 0 else gno end gno,case when datea = '000#000' then '日期/機台'
					else datea end date
,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10
from #result
order by gno,datea
Drop TABLE #result;